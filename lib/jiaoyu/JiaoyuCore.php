<?php

	/**
	 * This is the "kernel" of the framework as much as that metaphor makes sense.  It holds
	 * all of the configuration and anything else that might be needed app wide that doesn't
	 * fall under something more specific.
	 *
	 * @author Gabriel Comeau
	 * @package Jiaoyu
	 */
	class JiaoyuCore {

		/**
		 * Array of application-wide configuration directives.
		 */
		private static $config;

		/**
		 * Array of Route objects to be used in dispatch, redirects and url building.
		 */
		private static $routes;

		/**
		 * Base url for all urls generated by the application
		 */
		private static $baseUrl;

		/**
		 * All of the existing widgets loaded in from widgets.json
		 */
		private static $widgets;

		/**
		 * Load up all of the information that this class needs to hold onto during a request's
		 * lifetime.
		 */
		public static function init() {
			self::initErrorHandler();
			self::loadAppConfig();
			self::initDatabase();
			HttpCore::initSession();
			Auth::init();
			self::$baseUrl = HttpCore::getBaseUrl();
			self::loadRoutes();
			self::loadWidgets();
		}

		/**
		 * Static routes getter
		 */
		public static function getRoutes() {
			return self::$routes;
		}

		public static function baseUrl() {
			return self::$baseUrl;
		}

		/**
		 * Gets app-wide configuration values by string key.
		 *
		 * @param String $key The key to search for
		 * @return Mixed The value stored or null if the key isn't found.
		 */
		public static function config($key) {
			if (isset(self::$config[$key])) {
				return self::$config[$key];
			} else {
				// Should we throw an exception or return null?
				return null;
			}
		}

		/**
		 * Gets the widget info from the storage by key
		 *
		 * @param String $key The key to look for (the widget's name)
		 * @param Mixed Array if we find the widget info, null otherwise.
		 */
		public static function widget($key) {
			if (isset(self::$widgets[$key])) {
				return self::$widgets[$key];
			} else {
				return null;
			}
		}

		/**
		 * Read the application config file and build the key/value config settings
		 * that can be read with this classes' getConfig method.
		 */
		private static function loadAppConfig() {
			$appConfJson = file_get_contents(JIAOYU_PROJECT_HOME."/app/conf/config.json");
			try {
				$appConf = JsonUtils::decode($appConfJson);
			} catch (JsonException $e) {
				throw new ConfigurationException("Error initializing app config: ".$e->getMessage());
			}

			// OK - now we can load up the config array from the file
			foreach ($appConf as $configKey => $configValue) {
				self::$config[$configKey] = $configValue;
			}
		}

		/**
		 * Inits Atlas DBManager if app is configured to use the database
		 */
		private static function initDatabase() {
			if (self::Config('use_db')) {
				$host = self::Config('mysql_host');
				$user = self::Config('mysql_user');
				$pass = self::Config('mysql_password');
				$name = self::Config('mysql_dbname');
				DBManager::init($host, $user, $pass, $name);
			}
		}

		/**
		 * Read the routes configuration file and build the array of routes from it.
		 */
		private static function loadRoutes() {
			$appRoutesJson = file_get_contents(JIAOYU_PROJECT_HOME."/app/conf/routes.json");
			try {
				$appRoutes = JsonUtils::decode($appRoutesJson);
			} catch (JsonException $e) {
				throw new ConfigurationException("Error initializing app routes: ".$e->getMessage());
			}

			// Each json object in the array represents a route, so we should build them up
			// from the data.
			foreach ($appRoutes as $rawRoute) {
				self::$routes[] = Route::buildFromJson($rawRoute);
			}
		}

		/**
		 * Load up widget info from the widgets config file.  It doesn't actually build the widget
		 * objects because those should only get built at run time (they can take parameters and
		 * need to call controller actions)
		 */
		private static function loadWidgets() {
			$widgetsJson = file_get_contents(JIAOYU_PROJECT_HOME."/app/conf/widgets.json");

			// If the file is empty don't build the widgets
			if (!$widgetsJson) {
				return;
			}

			try {
				$appWidgets = JsonUtils::decode($widgetsJson);
			} catch (JsonException $e) {
				throw new ConfigurationException("Error initializing widgets: ".$e->getMessage());
			}

			// Each json object in the array is a widget, but unlike the routes we won't instantiate
			// the class, only set up some keys for later (because a widget needs to execute code at
			// run time to work)
			foreach ($appWidgets as $rawWidget) {
				if (!isset($rawWidget->name)) {
					throw new ConfigurationException("Malformed widget configuration file - each
						widget must have name, template, controller and action defined.");
				}

				$widget = Widget::buildFromJson($rawWidget);
				self::$widgets[$rawWidget->name] = $widget;
			}
		}

		/**
		 * Initialize the app-wide error handler
		 */
		private static function initErrorHandler() {
			set_exception_handler('ErrorHandler::handleExceptions');
			set_error_handler('ErrorHandler::handleErrors');
		}
	}
